# Cargo
## Cargo 基本命令
- 创建项目：
```rust
cargo new hello_world
cd hello_world
```
创建出来的项目目录：
```
$ tree
.
├── .git
├── .gitignore
├── Cargo.toml
└── src
    └── main.rs
```

- 运行项目
1. cargo run
2. 手动编译和运行项目
```
# 编译
cargo build
# 运行
./target/debug/hello_world
```

想要获取高性能代码，则可以加上`--release`选项
```
cargo run --release
cargo build --release
./target/release/hello_world
```

- 代码检查
`cargo check` 可以用比编译、运行更快的方式来验证代码的正确性

## Cargo.toml 和 Cargo.lock
- `Cargo.toml` 是 cargo 特有的项目数据描述文件，存储项目的所有元配置信息，如果 rust 开发者希望 Rust 项目可以按期望的方式进行构建、测试和运行，那么必须按照合理的方式构建 `Cargo.toml`。

- `Cargo.lock` 是 cargo 工具根据同一项目的 toml 文件生成的项目依赖详细清单，因此我们一般不需要修改它，只需要关注 `Cargo.toml` 即可。

> 什么时候该把 `Cargo.lock` 文件上传到 git 仓库中？
> 当项目是一个可运行程序时，就需要上传 `Cargo.lock` ；如果是一个依赖库项目，则需要将其放置在 `.gitignore` 中。

### package 配置段落
package 段落中记录项目的描述信息
```
[package]
name = "hello_world"
version = "0.1.0"
edition = "2021"
```
name 字段定义项目名称，version 字段定义当前项目版本，新项目默认为 0.1.0，edition 字段定义了当前项目使用的 Rust 的大版本。

### 定义项目依赖
在 Cargo.toml 中可以通过各种依赖段落来描述该项目的依赖项
- 基于 rust 官方仓库的 crates.io，通过版本号进行说明
- 基于项目源代码的 git 仓库地址，通过 URL 描述
- 基于本地项目的绝对路径或相对路径，通过类 UNIX 模式路径进行描述

具体写法：
```
[dependencies]
rand = "0.3"                        # 官方仓库 crates.io
hammer = { version = "0.5.0" }      # 官方仓库 crates.io
color = { git = "https://github.com/bjz/color-rs" } # 基于开源项目 git 地址
geometry = { path = "crates/geometry" }             # 基于本地项目路径
```

### 指定 debug 模式下才会执行的内容
```
if cfg!(debug_assertions) {
    ... // 这些内容只会在 debug 模式下执行 
}
```

### 依赖下载卡住

下载卡住其实就一个原因：下载太慢了。

根据经验来看，卡住不动往往发生在更新索引时。毕竟 Rust 的包越来越多，索引也越来越大，如果不使用国内镜像，卡住还蛮正常的，好在，我们也无需经常更新索引 :P

#### Blocking waiting for file lock on package cache

不过这里有一个坑，需要大家注意，如果你同时打开了 VSCODE 和命令行，然后修改了 Cargo.toml，此时 VSCODE 的 rust-analyzer 插件会自动检测到依赖的变更，去下载新的依赖。

在 VSCODE 下载的过程中（特别是更新索引，可能会耗时很久），假如你又在命令行中运行类似 cargo run 或者 cargo build 的命令，就会提示一行有些看不太懂的内容：
```
$ cargo build
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on package cache
```
其实这个报错就是因为 VSCODE 的下载太慢了，而且该下载构建还锁住了当前的项目，导致你无法在另一个地方再次进行构建。

解决办法也很简单：

- 增加下载速度
- 耐心等待持有锁的用户构建完成
- 强行停止正在构建的进程，例如杀掉 IDE 使用的 rust-analyzer 插件进程，然后删除 $HOME/.cargo/.package_cache 目录

# Rust 基础
## 变量
默认情况下，Rust的变量都是不可变的，可以通过在绑定时加上 `mut` 关键字，使其可变。

通常情况下，声明一个变量之后，但是不使用它，rust 会报告一个 warning，我们可以通过在命名时在前面加上 `_` 来达到告知编译器这就是一个不使用的变量的目的。

```
fn main() {
    let _x = 5;
    let y = 10;
}
```
使用 cargo run 运行下试试:

```
warning: unused variable: `y`
 --> src/main.rs:3:9
  |
3 |     let y = 10;
  |         ^ help: 如果 y 故意不被使用，请添加一个下划线前缀: `_y`
  |
  = note: `#[warn(unused_variables)]` on by default
```
可以看到变量 y 会发出警告，但是变量 _x 并不会发出警告。

也可以通过加上 `#[allow(unused_variables)]` 来消除警告

```
#[allow(unused_variables)]
fn main() {
    let x = 1;
}
```

### 变量遮蔽（shadowing）
rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的

## 基本类型
- 数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数
- 字符串：字符串字面量和字符串切片 &str
- 布尔类型： true和false
- 字符类型: 表示单个 Unicode 字符，存储为 4 个字节
- 单元类型: 即 () ，其唯一的值也是 ()

### 数值类型
| 长度 | 有符号类型 | 无符号类型 |
|------|-----------|-----------|
| 8 位 | i8         | u8        |
| 16 位	|i16	|u16|
| 32 位	|i32	|u32|
| 64 位	|i64	|u64|
| 128 位|i128   |	u128|
| 视架构而定 |isize|	usize|

默认整数类型为 `i32`，`isize` 和 `usize` 主要应用场景是用作集合的索引。

在 debug 模式下会检查整形溢出，但是在 release 模式下并不会检查整形溢出。

如果需要显示进行溢出处理，应该使用标准库中提供的一些函数：
- wrapping_* 方法在所有模式下按照补码循环溢出规则处理，例如 `wrapping_add`
- 如果使用 check_* 方法时发生溢出，则返回 None 值
- 使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
- 使用 saturating_* 方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，例如：`u8.Max.saturating_add(127)` 其值为 255（u8 所能表示的最大值）

默认浮点类型为 f64。

浮点数在某些特性上是反直觉的 例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 >，>= 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 f32 ， f64 上的比较运算实现的是 `std::cmp::PartialEq` 特征(类似其他语言的接口)，但是并没有实现 `std::cmp::Eq` 特征，但是后者在其它数值类型上都有定义，举例来说：

Rust 的 HashMap 数据结构，是一个 KV 类型的 Hash Map 实现，它对于 K 没有特定类型的限制，但是要求能用作 K 的类型必须实现了 std::cmp::Eq 特征，因此这意味着你无法使用浮点数作为 HashMap 的 Key，来存储键值对，但是作为对比，Rust 的整数类型、字符串类型、布尔类型都实现了该特征，因此可以作为 HashMap 的 Key。

为了避免上面说的两个陷阱，你需要遵守以下准则：

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

所以未定义的结果，会用 NaN 来处理，不能对 NaN 进行直接比较，可以调用 `is_nan()` 函数来判断当前值是否为 NaN。

### 字符、布尔、单元类型
rust 中字符为 Unicode 字符，所以 char 类型占用 4 个字节。

单元类型 `()`，其唯一的值也是 `()`。
其实 `fn main()` 函数返回的就是单元类型。也可以用单元类型作为 map 的值，表示我们只关注 key，不关注具体值，不占用任何内存。

### 表达式和语句
带有 `;` 的为语句，不带分号的为表达式。

永不返回的发散函数：当用 `!` 作函数返回类型时，表示该函数永不返回，该语法常用作程序崩溃函数。

```
fn dead_end() -> ! {
  panic!("你已经到了穷途末路，崩溃吧！");
}

// 无限循环，永不返回
fn forever() -> ! {
  loop {
    //...
  };
}
```

引用类型则是在普通类型前面加上 `&` 既可，例如 `i32` 类型的引用为 `&i32`。
引用默认不可变，若想声明为可变引用，则需要加上 `mut` 关键字。
可变引用也必须引用的是可变变量。
在同一作用域内，特定数据只能有一个可变引用，如果有多个可变引用指向同一变量时，会出现报错。
> 这种限制的好处在于rust在编译期就避免了数据竞争（只有一个可变引用指向某个变量）
可变引用和不可变引用不能同时存在
> 这种限制是因为正在借用不可变引用的用户，不希望有个可变引用修改变量值后，导致自己引用的值发生改变。

**在新编译器中，引用作用域的结束位置从花括号变成了最后一次使用的位置。**

## 复合类型
字符串切片索引是按字节为单位的。字符串切片类型标识是 `&str`，字符串字面量就是字符串切片
在对字符串使用切片语法时需要格外小心，切片的索引必须落在字符之间的边界位置，也就是 UTF-8 字符的边界，例如中文在 UTF-8 中占用三个字节，下面的代码就会崩溃：
```
 let s = "中国人";
 let a = &s[0..2];
 println!("{}",a);
```
因为我们只取 s 字符串的前两个字节，但是本例中每个汉字占用三个字节，因此没有落在边界处，也就是连 `中` 字都取不完整，此时程序会直接崩溃退出，如果改成 &s[0..3]，则可以正常通过编译。 

虽然 rust 中字符类型固定占用 4 个字节，但是在字符串中不一样，字符串是 UTF-8 编码，**字符串中的字符所占的字节数是变化的（1-4）。**

# 标准库

> 为啥String库中的trim设置成返回切片引用，而replace返回String
> 因为trim不会导致字符串长度增长，只会减少，也就不需要重新分配内存，所以返回切片效率更高。而replace可能导致长度增加，需要重新分配内存，因此只能返回一个新的所有权对象，也就是String